/** A “port“ in a solution graph, meaning an input or output node */
export interface Port {
    id: number // uniquely generated by server
    name: string
    constraints: object // displayed in tooltip
    tune?: boolean // is this parameter flagged as „tuneable“?
}

/** Data structure received by server containing a solution graph */
export interface SolutionGraphData {
    methods: {  // Array of „method“ nodes
        id: number // uniquely generated by server
        name: string
        inputs: Port[]
        outputs: Port[][]
        description: string | null
    }[]
    objects: {
        id: number // uniquely generated by server
        type: string
        name: string
        is_start: boolean
        is_end: boolean
        distance_to_start: number // length of longest path from start node, used for layout
        on_solution_path: boolean
        params: object
    }[]
    connections: {  // connections from output ports to objects and from objects to input ports
        fromId: number
        toId: number
    }[]
    nextId: number  // next unused id. successive ids can be assigned freely locally
}

/** Data structure received by server containing a knowledge graph */
export interface KnowledgeGraphData {
    types: {
        name: string,
        yaml: string  // displayed in tooltip
    }[]
    methods: {
        name: string
        description: string | null,
        yaml: string  // displayed in tooltip
    }[]
    connections: [string, string][]  // connections are specified by method or type name
}

export async function fetchKnowledgeGraph(graphName: string): Promise<KnowledgeGraphData> {
    let response = await fetch('/kg/' + graphName)
    return await response.json() as KnowledgeGraphData
}

export async function fetchSolutionGraph(graphName: string, startYML: string, targetYML: string): Promise<SolutionGraphData> {
    let response = await fetch('/s', {
        method: "POST",
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            "graph_name": graphName,
            "start": startYML,
            "target": targetYML
        })
    })

    if (!response.ok)
        throw response;  // Will be caught displayed as an error popup
    return await response.json() as SolutionGraphData;
}
